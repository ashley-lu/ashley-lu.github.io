---
layout: post
title: HW 1 - Blog Post 1
---

In this post, we'll be looking at NOAA climate data from several datasets. Let's
begin by importing all the necessary modules for the visualizations:

```python
import pandas as pd
from matplotlib import pyplot as plt
import numpy as np
import sqlite3
from sklearn.linear_model import LinearRegression
from plotly import express as px
```

### 1) Creating the SQL database using sqlite3

Since the dataset holding all the temperature data is so large, it is unlikely
that we will be using the entire dataset to create certain visualizations. In this
case, it is easier to create a SQL database that contains all of our data and
query from it the data we need. First, we create the climate database connection using
the sqlite3 package. If the database does not yet exist, it is created.

```python
#creating the database connection
conn = sqlite3.connect("climate.db")
```

We then read in the temperature data using the Pandas read_csv method. This time,
we specify a chunksize that causes the method to return an iterator containing
part of the data with the number of rows equaling the specified chunksize. The
data will be read in chunks when we send the data to the database.

```python
#reading the data in chunks since the file size is large
temps = pd.read_csv("temps.csv", chunksize = 100000)
```

Before adding the temperature data to the database, we can clean up the data and
make it more usable for later visualizations. The prepare_df method takes in a
dataframe and stacks the months such that we have a month column with each value
in the column corresponding to a month. We also rename the columns after stacking
for clarity, as well as changing the month values to be represented by integers
and dividing each temperature by 100 to obtain the temperature in degrees Celsius.
We will call this prepare_df method for each chunk of data we send to the database.

```python
def prepare_df(df):
    df = df.set_index(keys=["ID", "Year", "FIPS"])
    df = df.stack()
    df = df.reset_index()
    df = df.rename(columns = {"level_3"  : "Month" , 0 : "Temp"})
    df["Month"] = df["Month"].str[5:].astype(int)
    df["Temp"]  = df["Temp"] / 100
    return(df)
```

Now it's time to start sending the data to the climate database. We begin by
iterating through the temperature data using the temps iterator. For each chunk
of temperature data, we first create a FIPS code column by getting the first
two characters of each ID. This will help us later when it's time to query from
the database. Then, we prepare the chunk by calling prepare_df and finally
writing to the temperatures table in the climate database. We specify if_exists
to be "append" so that we do not overwrite the data each time we write to the table.

```python
#writing to the temperatures table in the database
for temp in temps:
    temp["FIPS"] = temp["ID"].str[0:2]
    temp = prepare_df(temp)
    temp.to_sql("temperatures", conn, if_exists = "append", index = False)
```

We do the same for the stations dataset, though this time we don't need to read
the data in chunks because the dataset is relatively small. In this case, we specify
if_exists to be "replace" because we're only writing to the stations table once.

```python
#writing to the stations table in the database
stations_url = "https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv"
stations = pd.read_csv(stations_url)
stations.to_sql("stations", conn, if_exists = "replace", index = False)
```

Finally, we write the data from the countries database to the countries table,
using the same if_exists parameter. We also prepare the database by renaming some
of the columns for later convenience.

```python
#writing to the countries table in the database
countries_url = "https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv"
countries = pd.read_csv(countries_url)
countries = countries.rename(columns = {"FIPS 10-4" : "FIPS", "Name": "Country"})
countries.to_sql("countries", conn, if_exists = "replace", index = False)
```

Now we have a fully populated climate database! We can view the list of tables in
the database by using the cursor to execute SQL commands. We get the names of the
tables from the sqlite_master table, and then call the fetchall method to return
a list of all the table names, which we then print.

```python
#viewing the list of tables in the database
cursor = conn.cursor()
cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
print(cursor.fetchall())
```

    [('temperatures',), ('stations',), ('countries',)]

We can also check to see if we populated the database correctly and make sure all
of the necessary columns and their data types are in the tables.

```python
#checking that we populated the database correctly
cursor.execute("SELECT sql FROM sqlite_master WHERE type='table';")
for result in cursor.fetchall():
    print(result[0])
```

    CREATE TABLE "temperatures" (
    "ID" TEXT,
      "Year" INTEGER,
      "FIPS" TEXT,
      "Month" INTEGER,
      "Temp" REAL
    )
    CREATE TABLE "stations" (
    "ID" TEXT,
      "LATITUDE" REAL,
      "LONGITUDE" REAL,
      "STNELEV" REAL,
      "NAME" TEXT
    )
    CREATE TABLE "countries" (
    "FIPS" TEXT,
      "ISO 3166" TEXT,
      "Country" TEXT
    )

It seems like everything has been added correctly, so now we can proceed to querying
data from the database and creating visualizations!

### 2) Average Yearly Change in Temperature in a Country

For our first visualization, let's tackle the question: How does the average
yearly change in temperature vary within a given country? To answer this question,
we will create an interactive geographic scatterplot using Plotly Express. This plot
will include a point for each station, in which the color of the point reflects
an estimate of the yearly change in temperature during the specified month and
time period at that station.

First, we begin by querying from the climate database. Based on our specifications,
we will specify the country, starting year, ending year, and month. We connect to
the climate database and create a SQL command for the cursor to execute. We select
the columns that we want in our queried dataframe and use left join to combine the
data from the different tables along a shared column, specifying the data that
matches the parameters we passed into the function. This is similar to the Pandas
merge function. Finally, we read the sql query into a new dataframe and return that
dataframe, making sure to close the database connection beforehand as this is good
practice.

```python
def query_climate_database(country, year_begin, year_end, month):
    conn = sqlite3.connect("climate.db")
    cmd = \
    """
    SELECT S.name, S.latitude, S.longitude, C.country, T.id, T.month, T.year, T.temp
    FROM temperatures T
    LEFT JOIN stations S ON T.id = S.id
    LEFT JOIN countries C ON T.fips = C.fips
    WHERE C.country == '{0}' AND T.year >= {1} AND T.year <= {2} AND T.month == {3}
    """.format(country, year_begin, year_end, month)
    climate = pd.read_sql_query(cmd, conn)
    climate.reset_index()
    conn.close()
    return climate
```

We can test our query function to make sure it works and we have all the necessary
columns.

```python
india = query_climate_database(country = "India",
                       year_begin = 1980,
                       year_end = 2020,
                       month = 1)
india.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>ID</th>
      <th>Month</th>
      <th>Year</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>1</td>
      <td>1980</td>
      <td>23.48</td>
    </tr>
    <tr>
      <th>1</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>1</td>
      <td>1981</td>
      <td>24.57</td>
    </tr>
    <tr>
      <th>2</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>1</td>
      <td>1982</td>
      <td>24.19</td>
    </tr>
    <tr>
      <th>3</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>1</td>
      <td>1983</td>
      <td>23.51</td>
    </tr>
    <tr>
      <th>4</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>1</td>
      <td>1984</td>
      <td>24.81</td>
    </tr>
  </tbody>
</table>
</div>

Using the LinearRegression method from scikit-learn, we can define a linear regression
for the Year and Temp columns. This will give us the coefficients for the average
change in temperature.

```python
def coef(data_group):
    x = data_group[["Year"]] # 2 brackets because X should be a df
    y = data_group["Temp"]   # 1 bracket because y should be a series
    LR = LinearRegression()
    LR.fit(x, y)
    return LR.coef_[0]
```

Now we can define the temperature_coefficient_plot function, which takes in the country,
starting year, ending year, month, and minimum number of observations as parameters.
We use **kwargs to represent the other parameters we can pass into the geographic
scatterplot like zoom and mapbox-style that may or may not be specified. First, we
query from the database. Then, we use groupby and apply to add a column of unique
Year counts per entry. We use this to compare against min_obs to see if there is
enough data for the station to be plotted. We also apply the linear regression to
obtain the coefficients. We then create the scatter plot, using parameters from **kwargs
if they were passed in and default parameters if not.

```python
def temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):
    df = query_climate_database(country, year_begin, year_end, month)
    temp = df.groupby(["NAME", "LATITUDE", "LONGITUDE", "Month"]).apply(lambda x: x['Year'].nunique())
    temp = pd.DataFrame(temp)
    temp.reset_index()
    temp = temp.rename(columns = {0 : "Count"})
    coefs = df.groupby(["NAME", "LATITUDE", "LONGITUDE", "Month"]).apply(coef)
    coefs = coefs.reset_index()
    coefs = coefs.rename(columns = {0 : "Estimated Yearly Increase (°C)"})
    coefs = pd.merge(coefs, temp, on = ["NAME", "LATITUDE", "LONGITUDE", "Month"])
    coefs = coefs[coefs["Count"] >= min_obs]

    if "zoom" in kwargs.items():
        z = kwargs.items()["zoom"]
    else:
        z = 2
    if "opacity" in kwargs.items():
        o = kwargs.items()["opacity"]
    else:
        o = 1
    if "height" in kwargs.items():
        h = kwargs.items()["height"]
    else:
        h = 600
    if "mapbox_style" in kwargs.items():
        m = kwargs.items()["mapbox_style"]
    else:
        m = "carto-positron"
    if "color_continuous_scale" in kwargs.items():
        c = kwargs.items()["color_continuous_scale"]
    else:
        c = px.colors.diverging.RdGy_r
    fig = px.scatter_mapbox(coefs,
                        lat = "LATITUDE",
                        lon = "LONGITUDE",
                        hover_name = "NAME",
                        color = "Estimated Yearly Increase (°C)",
                        zoom = z,
                        opacity = o,
                        height = h,
                        mapbox_style = m,
                        color_continuous_scale = c,
                        title = "Yearly Increase in Temperature in Month {0} for <br>Stations in {1}, Years {2}-{3}".format(month, country, year_begin, year_end)
                        )
    return fig
```

We test the temperature_coefficient_plot function using stations in India, with
observations from 1980-2020 in January.

```python
# assumes you have imported necessary packages
color_map = px.colors.diverging.RdGy_r # choose a colormap

fig = temperature_coefficient_plot("India", 1980, 2020, 1,
                                   min_obs = 10,
                                   zoom = 2,
                                   mapbox_style="carto-positron",
                                   color_continuous_scale=color_map)

write_html(fig, "geo_scatter.html")
```
{% include geo_scatter.html %}

We see that for most stations there has not been a significant change in average
temperature, but there are some outliers such as LUDHIANA and NORTH_LAKHIMPUR which
have seen a significant increase in average temperature.

### 3) Average temperature for a specific month and year across the world

Another interesting question we might ask is: What is the average temperature for
a specific month and year for all countries across the world? To answer this question,
we can create a choropleth that shows varying colors for different temperatures for
countries across the world.

Again, we query from the database to get the data we need. This time, we only need
to specify month and year.

```python
# Average temperature in a specified month, year for all countries - choropleth
def query_climate_database(year, month):
    conn = sqlite3.connect("climate.db")
    cmd = \
    """
    SELECT S.name, S.latitude, S.longitude, C.country, T.id, T.month, T.year, T.temp
    FROM temperatures T
    LEFT JOIN stations S ON T.id = S.id
    LEFT JOIN countries C ON T.fips = C.fips
    WHERE T.year == {0} AND T.month == {1}
    """.format(year, month)
    climate = pd.read_sql_query(cmd, conn)
    climate.reset_index()
    conn.close()
    return climate
```

We can test our query function, using January of 2020 as an example.

```python
choropleth = query_climate_database(year = 2020,
                       month = 1)
choropleth.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>ID</th>
      <th>Month</th>
      <th>Year</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>SHARJAH_INTER_AIRP</td>
      <td>25.333</td>
      <td>55.517</td>
      <td>United Arab Emirates</td>
      <td>AE000041196</td>
      <td>1</td>
      <td>2020</td>
      <td>18.88</td>
    </tr>
    <tr>
      <th>1</th>
      <td>DUBAI_INTL</td>
      <td>25.255</td>
      <td>55.364</td>
      <td>United Arab Emirates</td>
      <td>AEM00041194</td>
      <td>1</td>
      <td>2020</td>
      <td>20.40</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ABU_DHABI_INTL</td>
      <td>24.433</td>
      <td>54.651</td>
      <td>United Arab Emirates</td>
      <td>AEM00041217</td>
      <td>1</td>
      <td>2020</td>
      <td>19.70</td>
    </tr>
    <tr>
      <th>3</th>
      <td>AL_AIN_INTL</td>
      <td>24.262</td>
      <td>55.609</td>
      <td>United Arab Emirates</td>
      <td>AEM00041218</td>
      <td>1</td>
      <td>2020</td>
      <td>18.07</td>
    </tr>
    <tr>
      <th>4</th>
      <td>HERAT</td>
      <td>34.210</td>
      <td>62.228</td>
      <td>Afghanistan</td>
      <td>AFM00040938</td>
      <td>1</td>
      <td>2020</td>
      <td>2.61</td>
    </tr>
  </tbody>
</table>
</div>

To create a choropleth, we will need to read in a geojson file using the json module.

```python
#reading in the geojson file
from urllib.request import urlopen
import json

countries_gj_url = "https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/countries.geojson"

with urlopen(countries_gj_url) as response:
    countries_gj = json.load(response)
```

Now we are ready to create our second visualization. We define a function called
choropleth_avg_temperature that takes in a specified year and month as parameters.
First, we query the data from the climate database. Then, we calculate the average
temperature per country using the groupby and mean methods. Finally, we create
the choropleth, specifying the geojson file, country names as location, and
temperature as an indicator of color.

```python
def choropleth_avg_temperature(year, month):
    df = query_climate_database(year, month)
    df = df.rename(columns = {"Temp" : "Average Temperature (°C)"})
    month_avg = df.groupby("Country")[["Average Temperature (°C)"]].mean()
    month_avg = month_avg.reset_index()

    fig = px.choropleth(month_avg,
                    geojson=countries_gj,
                    locations = "Country",
                    locationmode = "country names",
                    color = "Average Temperature (°C)",
                    height = 600,
                    title = "Average Temperature (°C) in Month {0} of Year {1}".format(month, year))
    return fig

```

We test the choropleth_avg_temperature function by obtaining the choropleth that
shows the average temperature across all countries for January 2020.

```python
fig = choropleth_avg_temperature(2020, 1)
write_html(fig, "choropleth.html")
```
{% include choropleth.html %}

We see that the choropleth pretty accurately represents our perception of temperatures
around the world. Countries in the Northern Hemisphere are experiencing winter in
January, so the average temperature is low in those places. On the other hand, countries
in the Southern Hemisphere are experiencing summer in January, so the average temperature
is high in those places. Antarctica is relatively cold year-round, so it also displays
a lower average temperature.

### 4) Change in temperature over time for a station

Onto our last visualization! This time, let's answer the question: What is the
change in temperature over time for a station? We will use a line plot to represent
the answer to this question.

Again, let's query from the database to get the data we need. This time, we specify
a station and a country.

```python
# For a station of a particular country, what is the change in temperature over time? - lineplot
def query_climate_database(station, country):
    conn = sqlite3.connect("climate.db")
    cmd = \
    """
    SELECT S.name, S.latitude, S.longitude, C.country, T.id, T.month, T.year, T.temp
    FROM temperatures T
    LEFT JOIN stations S ON T.id = S.id
    LEFT JOIN countries C ON T.fips = C.fips
    WHERE S.name == '{0}' AND C.country == '{1}'
    """.format(station, country)
    climate = pd.read_sql_query(cmd, conn)
    climate.reset_index()
    conn.close()
    return climate
```

We test our query by obtaining the dataframe for the PBO_ANANTAPUR station in India.

```python
temp = query_climate_database(station = "PBO_ANANTAPUR", country = "India")
temp.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>ID</th>
      <th>Month</th>
      <th>Year</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>1</td>
      <td>1973</td>
      <td>24.97</td>
    </tr>
    <tr>
      <th>1</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>2</td>
      <td>1973</td>
      <td>27.37</td>
    </tr>
    <tr>
      <th>2</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>3</td>
      <td>1973</td>
      <td>30.12</td>
    </tr>
    <tr>
      <th>3</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>5</td>
      <td>1973</td>
      <td>32.80</td>
    </tr>
    <tr>
      <th>4</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>India</td>
      <td>IN001020700</td>
      <td>6</td>
      <td>1973</td>
      <td>28.93</td>
    </tr>
  </tbody>
</table>
</div>

Now, we define the temperature_over_time function that takes in a station and a country
and creates the line plot for the change in temperature over time. First, we obtain
the data we need by querying from the database. We add a Date column to our new
dataframe by using Pandas datetime, as well as the Year and Month columns. Finally,
we create the line plot using Plotly, specifying Date as the x and Temp as the y.

```python
def temperature_over_time(station, country):
    df = query_climate_database(station, country)

    #combining month and year using datetime
    df['Date'] = pd.to_datetime(df[['Year', 'Month']].assign(DAY = 1))
    fig = px.line(temp, x="Date", y="Temp", color="NAME",
                  line_group="NAME", hover_name="NAME", labels={
                  "Temp": "Temperature (°C)", "NAME" : "Station"},
                  title = "Change in Temperature Over Time for {0} in {1}".format(temp.iloc[0]["NAME"], temp.iloc[0]["Country"]))

    return fig
```

We test our temperature_over_time function by obtaining the line plot showing the
change in temperature over time for the PBO_ANANTAPUR station in India.

```python
fig = temperature_over_time(station = "PBO_ANANTAPUR", country = "India")
write_html(fig, "lineplot.html")
```
{% include lineplot.html %}

We observe that for the PBO_ANANTAPUR station in India, there has not been a
significant change in temperature over time, but in recent years temperature has
been increasing compared to past decades, most notably in the months April and May.

### Conclusion
From these visualizations, we can get a pretty good idea of what temperatures are
like around the world and how they have been changing over many decades. Clearly,
we should be more conscious of climate change, as temperatures are on the rise. I
hope that one day we'll be able to slow down climate change and see less stations
reporting a large increase in temperature.

{::options parse_block_html="true" /}
<div class="got-help">
Awaiting peer feedback!
</div>
{::options parse_block_html="false" /}

{::options parse_block_html="true" /}
<div class="gave-help">
Looking forward to looking at my peers' visualizations!
</div>
{::options parse_block_html="false" /}
